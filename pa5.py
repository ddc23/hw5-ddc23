import mathdef gcd(a, b):    if b == 0:        return a    if a < b:        a, b = b, a    return gcd(b, a % b)def remove_pairs(path):    opposite = {'N': 'S', 'S': 'N', 'E': 'W', 'W': 'E'}    if len(path) < 2:        return path        first, second = path[0], path[1]        if second == opposite.get(first, ''):        return remove_pairs(path[2:])    else:        return first + remove_pairs(path[1:])def bisection_root(f, a, b, tolerance=0.001):        fa = f(a)    fb = f(b)    if fa * fb > 0:        raise ValueError("No root found in the interval. The function values at the endpoints must have opposite signs.")    while abs(b - a) / 2 > tolerance:            mid = (a + b) / 2        fmid = f(mid)                if abs(fmid) < tolerance:            return mid                if fa * fmid < 0:            b = mid            fb = fmid        else:            a = mid            fa = fmid        return (a + b) / 2# Test with math.sin to approximate piapprox_pi = bisection_root(math.sin, 2, 4)pi_error = abs(math.pi - approx_pi)# Test with a linear function to find the root at 1.33approx_linear_root = bisection_root(lambda x: 1.33 - x, 1, 3)linear_error = abs(1.33 - approx_linear_root)# Test with a function to find sqrt(3)approx_sqrt3 = bisection_root(lambda x: x*x - 3, 1, 4)sqrt3_error = abs(math.sqrt(3) - approx_sqrt3)