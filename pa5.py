import math# List of tuples containing pairs of numbers to test the gcd functiontest_cases = [    (270, 192),    (35, 10),    (17, 100),    (256, 1024),    (49, 14),    (1000000, 2),    (123456, 654321)]# Function to compute the gcd using recursiondef gcd(a, b):    if b == 0:        return a    if a < b:        a, b = b, a    return gcd(b, a % b)# Applying the gcd function to each pair and printing the results# for a, b in test_cases: #   print(f"gcd({a}, {b}) = {gcd(a, b)}")def remove_pairs(path):    # Dictionary to identify opposite directions    opposite = {'N': 'S', 'S': 'N', 'E': 'W', 'W': 'E'}    # Base case: If the length of path is less than 2, nothing to remove    if len(path) < 2:        return path        # Check the first two characters    first, second = path[0], path[1]        # If they form a redundant pair, skip both and recurse on the rest    if second == opposite.get(first, ''):        return remove_pairs(path[2:])    else:        # Keep the first character and recurse on the rest        return first + remove_pairs(path[1:])# Example usage# print(remove_pairs("EEWN"))  # Should print "EN"# print(remove_pairs("SSNS"))  # Should print "SS"# print(remove_pairs("ESNW"))  # Should print "EW"# print(remove_pairs("EEWSES"))  # Should print "ESES"def bisection_root(f, a, b, tolerance=0.001):    """    Finds a root of the function f between x-values a and b using the bisection method.    Args:    f: A function that takes a single numerical input and outputs a numerical value.    a: Lower bound of the interval (x-value).    b: Upper bound of the interval (x-value).    tolerance: The tolerance level at which the y-value is considered close enough to zero to declare the root.    Returns:    The x-value of the root, if found within the tolerance.    Raises:    ValueError: If the signs of f(a) and f(b) are the same, indicating no root can be found between them.    """    fa = f(a)    fb = f(b)    # Check if the initial points do not bracket a root    if fa * fb > 0:        raise ValueError("No root found in the interval. The function values at the endpoints must have opposite signs.")    while abs(b - a) / 2 > tolerance:        # Compute the midpoint        mid = (a + b) / 2        fmid = f(mid)        # Check if we're close enough to zero        if abs(fmid) < tolerance:            return mid        # Determine the new interval [a, mid] or [mid, b]        if fa * fmid < 0:            b = mid            fb = fmid        else:            a = mid            fa = fmid    # Return the midpoint as an approximation of the root    return (a + b) / 2# Testing the function with the sine function and an interval around Ï€result = bisection_root(math.sin, 2, 4)result